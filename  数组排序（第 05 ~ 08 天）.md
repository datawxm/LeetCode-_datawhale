> 排序算法中有很多关于优化算法时间复杂度和空间复杂度的思考

# 冒泡排序
## 冒泡排序（Bubble Sort）基本思想
经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。

## 冒泡排序算法步骤
假设数组的元素个数为n,则冒泡排序的算法步骤如下:

1. 第1趟「冒泡」:对前n个元素执行「冒泡」,从而使第1个值最大的元素放置在正确位置上。
    1. 先将序列中第1个元素与第2个元素进行比较,如果前者大于后者,则两者交换位置,否则不交换。
    2. 然后将第2个元素与第3个元素比较,如果前者大于后者,则两者交换位置,否则不交换。
    3. 依次类推,直到第n-1个元素与第n个元素比较(或交换)为止。
    4. 经过第1趟排序,使得n个元素中第1个值最大元素被安置在第n个位置上。

2. 第2趟「冒泡」:对前n-1个元素执行「冒泡」,从而使第2个值最大的元素放置在正确位置上。
    1. 先将序列中第1个元素与第2个元素进行比较,若前者大于后者,则两者交换位置,否则不交换。
    2. 然后将第2个元素与第3个元素比较,若前者大于后者,则两者交换位置,否则不交换。
    3. 依次类推,直到第n-2个元素与第n-1个元素比较(或交换)为止。
    4. 经过第2趟排序,使得数组中第2个值最大元素被安置在第n-1个位置上。

3. 依次类推,重复上述「冒泡」过程,直到某一趟排序过程中不出现元素交换位置的动作,则排序结束。

``` python
# 冒泡排序的代码实现
class Solution:
    def bubbleSort(self, nums):
        if not nums:
            return []
        n = len(nums)
        for i in range(n - 1):
            flag = False
            for j in range(n - i - 1):
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    flag = True
            if not flag:
                break
        return nums

    def sortArray(self, nums):
        return self.bubbleSort(nums)


print(Solution().sortArray([5, 3, 4, 1, 2, 6]))
```