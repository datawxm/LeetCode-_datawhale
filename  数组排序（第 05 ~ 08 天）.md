> 排序算法中有很多关于优化算法时间复杂度和空间复杂度的思考，这同时也让我想起了小时候打牌码牌的过程，实际就是在排序。

# 冒泡排序
## 冒泡排序（Bubble Sort）基本思想
经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。

## 冒泡排序算法步骤
假设数组的元素个数为n,则冒泡排序的算法步骤如下:

1. 第1趟「冒泡」:对前n个元素执行「冒泡」,从而使第1个值最大的元素放置在正确位置上。
    1. 先将序列中第1个元素与第2个元素进行比较,如果前者大于后者,则两者交换位置,否则不交换。
    2. 然后将第2个元素与第3个元素比较,如果前者大于后者,则两者交换位置,否则不交换。
    3. 依次类推,直到第n-1个元素与第n个元素比较(或交换)为止。
    4. 经过第1趟排序,使得n个元素中第1个值最大元素被安置在第n个位置上。

2. 第2趟「冒泡」:对前n-1个元素执行「冒泡」,从而使第2个值最大的元素放置在正确位置上。
    1. 先将序列中第1个元素与第2个元素进行比较,若前者大于后者,则两者交换位置,否则不交换。
    2. 然后将第2个元素与第3个元素比较,若前者大于后者,则两者交换位置,否则不交换。
    3. 依次类推,直到第n-2个元素与第n-1个元素比较(或交换)为止。
    4. 经过第2趟排序,使得数组中第2个值最大元素被安置在第n-1个位置上。

3. 依次类推,重复上述「冒泡」过程,直到某一趟排序过程中不出现元素交换位置的动作,则排序结束。

``` python
# 冒泡排序的代码实现
class Solution:
    def bubbleSort(self, nums):
        if not nums:
            return []
        n = len(nums)
        for i in range(n - 1):
            flag = False
            for j in range(n - i - 1):
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    flag = True
            if not flag:
                break
        return nums

    def sortArray(self, nums):
        return self.bubbleSort(nums)


print(Solution().sortArray([5, 3, 4, 1, 2, 6]))
```

## 冒泡排序算法分析
时间复杂度：加了 $flag = False$ 的算法优化，时间复杂度为 $O(n)$ 到 $O(n^2)$；  
空间复杂度：冒泡排序是直接在原数组上修改，属于原地排序算法，空间复杂度为 $O(1)$。  

# 选择排序
## 选择排序（Selection Sort）基本思想：
将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。  

## 选择排序算法步骤
假设数组的元素个数为n，则选择排序的算法步骤如下:

1. 初始状态下，无已排序区间，未排序区间为[0, n-1]。

2. 第1趟选择:
   1. 遍历未排序区间[0, n-1]，使用变量 $min\_i$ 记录区间中值最小的元素位置。
   2. 将 $min\_i$ 与下标为0处的元素交换位置。如果下标为0处元素就是值最小的元素位置，则不用交换。
   3. 此时，[0, 0]为已排序区间，[1, n-1]（总共n-1个元素）为未排序区间。

3. 第2趟选择:
   1. 遍历未排序区间[1, n-1]，使用变量 $min\_i$ 记录区间中值最小的元素位置。
   2. 将 $min\_i$ 与下标为1处的元素交换位置。如果下标为1处元素就是值最小的元素位置，则不用交换。
   3. 此时，[0, 1]为已排序区间，[2, n-1]（总共n-2个元素）为未排序区间。

4. 依次类推，对剩余未排序区间重复上述选择过程，直到所有元素都划分到已排序区间，排序结束。

```python
# 选择排序代码实现
# 选择排序的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，
# 第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，直到整个数组有序。
# 选择排序的时间复杂度为O(n^2)。
# 选择排序是不稳定的排序方法。
class Solution:
    def selectionSort(self, nums):
        n = len(nums)
        for i in range(n - 1):
            min_index = i
            for j in range(i, n):
                if nums[j] < nums[min_index]:
                    min_index = j
            if i != min_index:
                nums[i], nums[min_index] = nums[min_index], nums[i]
        return nums

    def sortArray(self, nums):
        return self.selectionSort(nums)
print(Solution().sortArray([5, 2, 3, 1]))
```

## 选择排序算法分析
- **时间复杂度**：选择排序和冒泡排序一样，时间复杂度都是$O(n^2)$。  
- **空间复杂度**：也是在原数组上直接修改，空间复杂度$O(1)$。  
冒泡排序是稳定排序算法，对相同键值的元素，排序后会保持原数组中的相对顺序；选择排序是不稳定排序算法，排序后，相同键值的元素原相对顺序可能发生改变。  

# 插入排序
## 插入排序（Insertion Sort）基本思想：
> 看到一起学习的同学文档说，插入排序特别像打牌起排
将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。  
插入排序在每次插入一个元素时，该元素会在有序区间找到合适的位置，因此每次插入后，有序区间都会保持有序。

## 插入排序算法步骤
假设数组的元素个数为n个，则插入排序的算法步骤如下：

1. **初始状态**：
   - 有序区间为 `[0,0]`
   - 无序区间为 `[1,n-1]`

2. **第1趟插入**：
   1. 取出无序区间 `[1,n-1]` 中的第1个元素，即 `nums[1]`
   2. 从右到左遍历有序区间中的元素，将比 `nums[1]` 小的元素向后移动1位
   3. 如果遇到大于或等于 `nums[1]` 的元素时，说明找到了插入位置，将 `nums[1]` 插入到该位置
   4. 插入元素后有序区间变为 `[0,1]`，无序区间变为 `[2,n-1]`

3. **第2趟插入**：
   1. 取出无序区间 `[2,n-1]` 中的第1个元素，即 `nums[2]`
   2. 从右到左遍历有序区间中的元素，将比 `nums[2]` 小的元素向后移动1位
   3. 如果遇到大于或等于 `nums[2]` 的元素时，说明找到了插入位置，将 `nums[2]` 插入到该位置
   4. 插入元素后有序区间变为 `[0,2]`，无序区间变为 `[3,n-1]`

4. **依次类推**，对剩余无序区间中的元素重复上述插入过程，直至所有元素都插入到有序区间中，排序结束。
```python
# 插入排序代码实现
# 插入排序的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。
# 插入排序的时间复杂度是O(n^2)。
class Solution:
    def insertSort(self, nums):
        n = len(nums)
        for i in range(1, n):
            temp = nums[i]
            j = i
            while j > 0 and nums[j - 1] > temp:
                nums[j] = nums[j - 1]
                j -= 1
            nums[j] = temp
        return nums

    def sortArray(self, nums):
        return self.insertSort(nums)
print(Solution().sortArray([5, 2, 3, 1]))  # [1, 2, 3, 5]
```

## 插入排序算法分析
- **时间复杂度**：冒泡、选择、插入排序时间复杂度都是$O(n^2)$。  
- **空间复杂度**：都是在原数组上直接修改，空间复杂度$O(1)$。  
插入排序是稳定排序算法。

# 小结
冒泡排序、选择排序和插入排序都是使用双层循环，通过一种“迭代-选择”模式来工作的。

- 冒泡排序：外层循环控制所有的遍历轮数，内层循环则在每一轮中通过相邻元素的比较和交换，将当前未排序部分的最大（或最小）元素“冒泡”到正确的位置。

- 选择排序：外层循环控制所有的遍历轮数，内层循环则在每一轮中找出当前未排序部分的最小（或最大）元素，并将其放到已排序部分的末尾。

- 插入排序：外层循环逐个遍历未排序部分的元素，内层循环则在每一轮中找出当前元素在已排序部分的正确位置，并将其插入。

这三种算法都是通过逐个处理元素，逐步将未排序部分转化为已排序部分，从而实现整个数组的排序。

# 归并排序
## 归并排序（Merge Sort）基本思想：

采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。

## 归并排序算法步骤
假设数组的元素个数为几个,则归并排序的算法步骤如下:
1. 分解过程:先递归地将当前数组平均分成两半,直到子数组长度为1。
	1. 找到数组中心位置mid,从中心位置将数组分成左右两个子数left_nums、right_nums.
	2. 对左右两个子数组left_nums、right_nums分别进行递归分解。
	3. 最终将数组分解为n个长度均为1的有序子数组。
2. 归并过程:从长度为1的有序子数组开始,依次将有序数组两两合并,直到合并成一个长度为n的有序数组。
	1. 使用数组变量nums存放合并后的有序数组。
	2. 使用两个指针lefti、righti分别指向两个有序子数组lefft_nums、right_nums的开始位置。
	3. 比较两个指针指向的元素,将两个有序子数组中较小元素依次存入到结果数组nums中,并将指针移动到下一位置。
	4. 重复步骤3,直到某一指针到达子数组末尾。
	5. 将另一个子数组中的剩余元素存入到结果数组nums中。
	6. 返回合并后的有序数组nums。

```python
# 归并排序代码实现
# 递归实现
# 递归的终止条件是数组的长度为1
# 递归的过程是将数组分为两部分，然后对两部分分别进行排序，最后合并两部分
# 时间复杂度O(nlogn)
# 空间复杂度O(n)
# 稳定排序

class Solution:
    # 合并过程
    def merge(self, left_nums, right_nums):
        nums = []
        i, j = 0, 0
        while i < len(left_nums) and j < len(right_nums):
            if left_nums[i] < right_nums[j]:
                nums.append(left_nums[i])
                i += 1
            else:
                nums.append(right_nums[j])
                j += 1
        
        while i < len(left_nums):
            nums.append(left_nums[i])
            i += 1
        
        while j < len(right_nums):
            nums.append(right_nums[j])
            j += 1
        return nums

    # 递归过程
    def mergeSort(self, nums):
        if len(nums) <= 1:
            return nums
        
        mid = len(nums) // 2
        left_nums = self.mergeSort(nums[:mid])
        right_nums = self.mergeSort(nums[mid:])
        
        return self.merge(left_nums, right_nums)

    def sortArray(self, nums):
        return self.mergeSort(nums)
print(Solution().sortArray([5,2,3,1]))
```

## 归并排序算法分析
- **时间复杂度**：归并排序采用分而治之的策略，时间复杂度等于归并趟数与每一趟归并的时间复杂度乘积。子算法`merge(self, left_nums, right_nums):`的时间复杂度为$O(n)$ 
- **空间复杂度**：$O(n)$。归并排序方法需要用到与参加排序的数组同样大小的辅助空间。因此，算法的空间复杂度为 $O(n)$。
归并排序为稳定算法，相同键值元素原始的相对顺序不改变。

